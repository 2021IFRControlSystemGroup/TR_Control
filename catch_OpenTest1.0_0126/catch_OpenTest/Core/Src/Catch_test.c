#include "robo_base.h"
#include "can.h"
#include "Catch_test.h"
#include "main.h"

//extern ROBO_BASE Robo_Base; 
//extern Speed_System* P_Speed; 
extern ROBO_CATCH robo_catch;
extern CAN_HandleTypeDef hcan1;
int speed;
int pos;
int flag;

int state;
int shot;
//void catch_open(void)
//{

//	
//   switch(robo_catch.Open_flag)
//	 {
//	   case 1:robo_catch.SPEED_systemOpen.Tar_Speed=-speed;break;        
//	   case 2:robo_catch.SPEED_systemOpen.Tar_Speed=speed;break;	
//     case 0:robo_catch.SPEED_systemOpen.Tar_Speed=0;break;		
//     default:break;		 
//	 }
//      
//}

////速度环标定
//void catch_line_speed(void)
//{
//	 switch(robo_catch.Line_flag)  //1.3移动到中间停止，1.2.3移动到一端再回到中间。
//	 {
//	   case 1:robo_catch.SPEED_systemLine.Tar_Speed=100;break;        
//	   case 0:robo_catch.SPEED_systemLine.Tar_Speed=0;break;	
//     case 2:robo_catch.SPEED_systemLine.Tar_Speed=-100;break;		 
//		 default:break;
//	 }
//     
//}


////五个位置
//void catch_line_pos(void)
//{
//	 switch(robo_catch.Line_flag)  //移动一个角度
//	 {
//	   case 1:robo_catch.Pos_systemLine.Tar_Pos=pos;break;        
//	   case 2:robo_catch.Pos_systemLine.Tar_Pos=-pos;break;	
//     case 0:robo_catch.Pos_systemLine.Tar_Pos=0;break;		 
//		 default:break;
//	 }
//     
//}


WorkState_e Work_Status = PREPARE_STATE;
//static int PosCount = 0;
int last_Open;
int last_Line;
//获取状态
uint8_t GetWorkStatus(void)
{
	return Work_Status;
}


/*
目标由上一次状态确定，目标不改变
本电机的速度
pid进状态多次才结束转动
夹子打开为负关闭为正
*/
void Work_Mode_Change(void)
{
		switch(GetWorkStatus())
	{
		case PREPARE_STATE:
		{
				robo_catch.SPEED_systemOpen.Tar_Speed=0;
			  robo_catch.SPEED_systemLine.Tar_Speed=0;
	      flag=0;	      
			  HAL_Delay(1000);
			  Work_Status = CALIBRATION_LINE;
			break;
		}
		case CALIBRATION_LINE:  //01  OK
		{ 
			state=1;
			
			if(robo_catch.line_speed_flag)
			{
			    robo_catch.SPEED_systemLine.Tar_Speed = -300;
				  robo_catch.SPEED_systemOpen.Tar_Speed=0;
			    flag=0;	 
				  Work_Status = CALIBRATION_LINE;
			}
			else
				{
				  Work_Status = CALIBRATION_CLIP;
					robo_catch.SPEED_systemLine.Tar_Speed = 0;   
					robo_catch.SPEED_systemOpen.Tar_Speed=100;     
					flag=0;
				}					
					
			break;
		}
		case CALIBRATION_CLIP:  //02  ok
		{
			state = 2;
			
			if(robo_catch.open_flag == 0)
			{
			    robo_catch.SPEED_systemOpen.Tar_Speed = 0;
				  robo_catch.SPEED_systemLine.Tar_Speed = 0;
			    flag = 0;
				 Work_Status = OPEN_STATE;
				last_Open = robo_catch.Pos_systemOpen.Info.Abs_Angle;    
				last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
				
			}
			break;
		}
		case OPEN_STATE:   //03     ok          //判断状态结束是电机不疯的关键
		{
      state = 3;		
      
			if(state == 3)
				 {
						robo_catch.Pos_systemOpen.Tar_Pos = -20000 + last_Open;      
						robo_catch.Pos_systemLine.Tar_Pos = last_Line;
						flag = 1;
				static int count = 0;
				count++;
				if(robo_catch.Pos_systemOpen.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			  {
             Work_Status = CLOSE_STATE;	
					   last_Open = robo_catch.Pos_systemOpen.Info.Abs_Angle;      //为了让目标值不变，改成上一个状态确定大小
					   HAL_Delay(1000);
				}		
			}			
	    break;
		}
		case CLOSE_STATE:  //04    ：利用光电门切换到5，
		{	
			
			state =4;
			
					  if(state == 4) //抓取到置位4
			      {
							   
			           robo_catch.Pos_systemOpen.Tar_Pos =   2000 + last_Open ;        
				         robo_catch.Pos_systemLine.Tar_Pos = last_Line ;      
				         flag = 1;   
							if(robo_catch.Pos_systemOpen.Info.Speed == 0 && robo_catch.open_flag == 0)     //利用光电门确定关闭
			        {
								 Work_Status = ENDPOINT_STATE;	
								 last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;     //为了让目标值不变，改成上一个状态确定大小
				       }
					 }			
			break;
		}
		case ENDPOINT_STATE:    //05  OK     
		{
			state = 5;
			
			if(state == 5)    
			{
			    robo_catch.Pos_systemLine.Tar_Pos = 1000+last_Line;
				  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;   
			    flag = 1;
				static int count = 0;    //判断结束
				count++;
				if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)  
			  {
             
					   last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;     //为了让目标值不变，改成上一个状态确定大小
					if(1)
					{
					   shot = 1;            //编写判断：接触好后为1
					   Work_Status = POS_STATE;
					}
					   
				}		
			}
				
			break;
		}
		
		
		case POS_STATE:   //06       OK来回
		{
			state = 6;
			
			
//			if( (state == 6) && (shot == 1))     //箭与发射架接好后置位6  发射完shot置位1 ，5次
//			{		
//				  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
//					if(PosCount<5) 
//					{
			switch(shot)
			{
				
				case 1:
				{
					
							robo_catch.Pos_systemLine.Tar_Pos = -1000+last_Line;    
						  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;
							flag = 1;									
						  static int count = 0;
				      count++;
				      if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			        {
								  shot = 2;
								  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
								HAL_Delay(500);
							}
							break;
					}
				
					case 2:
				{
							robo_catch.Pos_systemLine.Tar_Pos = -1000+last_Line;    
						  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;
							flag = 1;									
						  static int count = 0;
				      count++;
				      if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			        {
								  shot = 3;
								  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
								HAL_Delay(500);
							}
							break;
					}
				case 3:
				{
							robo_catch.Pos_systemLine.Tar_Pos = -1000+last_Line;    
						  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;
							flag = 1;									
						  static int count = 0;
				      count++;
				      if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			        {
								  shot = 4;
								  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
								HAL_Delay(500);
							}
							break;
					}
				case 4:
				{
							robo_catch.Pos_systemLine.Tar_Pos = -1000+last_Line;    
						  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;
							flag = 1;									
						  static int count = 0;
				      count++;
				      if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			        {
								  shot = 5;
								  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
								  HAL_Delay(500);
							}
							break;
					}
				case 5:
				{
							robo_catch.Pos_systemLine.Tar_Pos = -1000+last_Line;    
						  robo_catch.Pos_systemOpen.Tar_Pos = last_Open;
							flag = 1;									
						  static int count = 0;
				      count++;
				      if(robo_catch.Pos_systemLine.Info.Speed == 0 && count > 3)   //   和电机pid参数有关，把pid参数设大一点
			        {
								  shot = 6;
								  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
								HAL_Delay(500);
							}
							break;
					}
				case 6:
					{
						Work_Status = RESTART_LINE;		
						last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle; 
					}
					break;
				}	
		
				
	
			break;
			}
     
			
	/*
			添加一个函数：让位置环电机结束
			*/
//消除误差重新标定			
		case RESTART_LINE:  //07              OK           //夹子打开-，关闭+
		{
			if(robo_catch.line_speed_flag)
			{
			  robo_catch.SPEED_systemLine.Tar_Speed = 200;
			  robo_catch.SPEED_systemOpen.Tar_Speed = 0;
				flag = 0;
				Work_Status = RESTART_LINE;
			}
			else
			{
				robo_catch.SPEED_systemLine.Tar_Speed = 0;
			  robo_catch.SPEED_systemOpen.Tar_Speed = 200;
				flag=0;
			  Work_Status = RESTART_CLIP;
			}		 
			     

			break;
		}
		
		case RESTART_CLIP:  //08  ok
		{
			if(robo_catch.open_flag == 0)
			{
			    robo_catch.SPEED_systemLine.Tar_Speed = 0;
			    robo_catch.SPEED_systemOpen.Tar_Speed= 0;
			    flag = 0;
			    Work_Status = OPEN_STATE;
				  last_Line = robo_catch.Pos_systemLine.Info.Abs_Angle;
				  last_Open = robo_catch.Pos_systemOpen.Info.Abs_Angle;
			} 	
			break;
		}
		
	}
}



